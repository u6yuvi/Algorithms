'''
Permute Array Of Unique Integers
Given an array of unique numbers, return in any order all its permutations.

Example
{
"arr": [1, 2, 3]
}
Output:

[
[1, 2, 3],
[1, 3, 2],
[2, 1, 3],
[2, 3, 1],
[3, 2, 1],
[3, 1, 2]
]

'''

def permute(arr):

    result = []
    slate = []

    def perm_helper(arr,i,slate):
        #base case
        if i==len(arr):
            result.append(slate[:])
            return
        #recursive case
        else:
            for pick in range(i,len(arr)):
                arr[pick], arr[i] = arr[i], arr[pick]
                slate.append(arr[i])
                perm_helper(arr,i+1,slate)
                arr[pick], arr[i] = arr[i], arr[pick]
                slate.pop()
        return
    
    perm_helper(arr,0,slate)
    return result

'''
    
    Time Complexity: Leaf + Intermediate
                     O(n!*n) + <O(n!*n)
                     
    Show that the time taken by the intermediate workers are less than leaf workers:
    No of Leaf Workers - n! 
    Copy the results of size n 
    Time Complexity of Leaf Workers - n!*n
    
    At level 0 ,the number of worker is 1 and worker has 3 choices i.e  Total - n*1 
    At level 1 , the number of worker is n and worker has n-1 choices i.e Tota - n*n-1
    
    
    Space Complexity: Input + Aux + Output
                     O(n)   +  O(n)[Height of the call stack , slate is mutable]   +   O(n!*n)
    
    
    '''

# print(permute([1,2,3]))

#--------------------------------Question-2------------------------------------
'''

Given a string, return all strings that can be generated by changing case of one or more letters in it.

Example One
{
"s": "a1z"
}
Output:

["A1Z", "A1z", "a1Z", "a1z"]

'''
def letter_case_permutations(s):
    """
    Args:
     s(str)
    Returns:
     list_str
    """
    # Write your code here.
    result = []
    slate = []
    
    def letter_helper(s,i,slate):
        #base case
        if i == len(s):
            result.append("".join(slate))
            return 
        #recursive case
        else:
            if s[i].isalpha():
                slate.append(s[i].upper())
                letter_helper(s,i+1,slate)
                slate.pop()
                slate.append(s[i].lower())
                letter_helper(s,i+1,slate)
                slate.pop()
            elif s[i].isdigit():
                slate.append(s[i])
                letter_helper(s,i+1,slate)
                slate.pop()
        return

    letter_helper(s,0,slate)
    return result

'''
Time Complexity : Leaf Node + Intermediate Node
                 O(2^n * n)  + O(2^n*1) -Number of nodes is no more than 2^n when compared with penultimate layer
Space Complexity : Input + Aux Space + Output
                  O(n)   + O(n) + O(2^n*n)
                    
                    
                    '''
# print(letter_case_permutations("a1z"))


#--------------------------Question-3-----------------------
'''
Generate All Subsets Of A Set
Generate ALL possible subsets of a given set. The set is given in the form of a string s containing distinct lowercase characters 'a' - 'z'.

Example
{
"s": "xy"
}
Output:

["", "x", "y", "xy"]

'''


def generate_all_subsets(s):
    """
    Args:
    s(str)
    Returns:
    list_str
    """
    # Write your code here.

    slate = []
    result = []

    def generate_all_subset_helper(s,i,slate):
        #base case
        if i == len(s):
            result.append("".join(slate))
            return
        
        #recursive case
        else:
            #exclude case
            generate_all_subset_helper(s,i+1,slate)

            #include
            slate.append(s[i])
            generate_all_subset_helper(s,i+1,slate)
            slate.pop()

        return
    
    generate_all_subset_helper(s,0,slate)

    return result
'''
Time Complexity - Leaf Node + Intermediate Node
                2^n * n   + < 2^n*1
Space Complexity - Input + Aux + Output
                    O(n) + O(n) + O(2^n*n)
'''

# print("Generate all subset:",generate_all_subsets("xy"))



#------------------------Question-4--------------------------------------

'''
Permute Array Of Integers Duplicates Allowed
Given an array of numbers with possible duplicates, return all of its permutations in any order.

Example
{
"arr": [1, 2, 2]
}
Output:

[
[1, 2, 2],
[2, 1, 2],
[2, 2, 1]
]

'''


def get_permutations(arr):
    """
    Args:
     arr(list_int32)
    Returns:
     list_list_int32
    """
    # Write your code here.

    slate = []
    result = []
    
    def get_permut_helper(arr,i,slate):
        #base case
        if i==len(arr):
            result.append(slate[:])
            return
        #recursion case
        else:
            hmap = {}
            for pick in range(i,len(arr)):
                if arr[pick] not in hmap.keys():
                    hmap[arr[pick]] = 1
                    arr[pick], arr[i] = arr[i], arr[pick]
                    slate.append(arr[i])
                    get_permut_helper(arr,i+1,slate)
                    slate.pop()
                    arr[pick], arr[i] = arr[i], arr[pick]

    
    get_permut_helper(arr,0,slate)
    return result

'''
Worst Case is when all numbers are unique.....
    Time Complexity: Leaf + Intermediate
                     O(n!*n) + <O(n!*n)
                     
    Show that the time taken by the intermediate workers are less than leaf workers:
    No of Leaf Workers - n! 
    Copy the results of size n 
    Time Complexity of Leaf Workers - n!*n
    
    At level 0 ,the number of worker is 1 and worker has 3 choices i.e  Total - n*1 
    At level 1 , the number of worker is n and worker has n-1 choices i.e Tota - n*n-1
    
    
    Space Complexity: Input + Aux + Output
                     O(n)   +  O(n)[Height of the call stack , slate is mutable]   +   O(n!*n)
    
    
    '''
# print(get_permutations([1, 2, 2]))


#-------------------------Question-5-----------------------------------

'''
Subsets With Duplicate Characters
Given a string that might contain duplicate characters, find all the possible distinct subsets of that string.

Example One
{
"s": "aab"
}
Output:

["", "a", "aa", "aab", "ab", "b"]

'''
def get_distinct_subsets(s):
    """
    Args:
     s(str)
    Returns:
     list_str
    """
    # Write your code here.

    slate = []
    result = []
    s = sorted(s)
    def get_distinct_helper(arr,i,slate):
        #base case
        if i==len(arr):
            result.append("".join(slate))
            return

        # recursive case
        else:
            cnt = 0
            cnt = sum([1 for j in s[i:] if j==s[i]])
            #exclude case
            get_distinct_helper(arr,i+cnt,slate)

            #include case
            for pick in range(1,cnt+1):
                slate.append(s[i])
                get_distinct_helper(arr,i+cnt,slate)
            for pick in range(1,cnt+1):
                slate.pop()


    get_distinct_helper(s,0,slate)
    return result

'''
Time Complexity - Leaf Node + Intermediate Node
                O(2^n*n)     +  O(2^n*1)
Space Complexity - Input  + Aux + Output
                   O(n)   + O(n)  + O(2^n *n)
'''

# print(get_distinct_subsets("aab"))


#-----------------Question-6---------------------------

'''
Given a seven-digit phone number, return all the character combinations 
that can be generated according to the following mapping:

{
"phone_number": "1234567"
}
Output:

[
"adgjmp",
"adgjmq",
"adgjmr",
"adgjms",
"adgjnp",
...
"cfilns",
"cfilop",
"cfiloq",
"cfilor",
"cfilos"
]
First string "adgjmp" in the first line comes from the first characters mapped 
to digits 2, 3, 4, 5, 6 and 7 respectively. Since digit 1 maps to nothing, nothing 
is appended before 'a'. Similarly, the fifth string "adgjnp" generated from first 
characters of 2, 3, 4, 5 second character of 6 and first character of 7. 
All combinations generated in such a way must be returned in the lexicographical order.
'''


def get_words_from_phone_number(phone_number):
    """
    Args:
     phone_number(str)
    Returns:
     list_str
    """
    # Write your code here.
    hash_map = {"2":["a","b","c"],"3":["d","e","f"],"4":["g","h","i"],"5":["j","k","l"],"6":["m","n","o"],
        "7":["p","q","r","s"],"8":["t","u","v"],"9":["w","x","y","z"]}

    slate = []
    result = []
    
    def get_words_helper(phone_number,i,slate):
        #base case
        if i==len(phone_number):
            result.append("".join(slate))
            return
        #recursive case
        elif (phone_number[i]!="1") and (phone_number[i]!="0"):
            for pick in hash_map[str(phone_number[i])]:
                slate.append(pick)
                get_words_helper(phone_number,i+1,slate)
                slate.pop()
        else:
            get_words_helper(phone_number,i+1,slate)    
        return

    get_words_helper(phone_number,0,slate)
    return result

'''
    Time Complexity - Leaf Node + Intermediary Node
                      O(4^n *n)  +  <O(4^n)
    Space Complexity - Input + Aux Space + Output
                       O(n).  + O(n). + O(4^n * n)
'''

# print(get_words_from_phone_number("1234567"))

#-----------------------Question-7--------------------

'''
N Choose K Combinations
Given two integers n and k, find all the possible unique combinations of k numbers in range 1 to n.

Example One
{
"n": 5,
"k": 2
}
Output:

[
[1, 2],
[1, 3],
[1, 4],
[1, 5],
[2, 3],
[2, 4],
[2, 5],
[3, 4],
[3, 5],
[4, 5]
]
'''



def find_combinations(n, k):
    """
    Args:
     n(int32)
     k(int32)
    Returns:
     list_list_int32
    """
    # Write your code here.

    slate = []
    result = []

    def find_combinations_helper(s,i,slate,k):
        
        #backtracking case
        if len(slate)==k:
            result.append(slate[:])
            return
        
        #redundant code in this case as the step size of slate it increasing by 1 so upper condition will be met first.
        if len(slate)>k:
            return 

        # if len(slate)<k:

        #base case
        if i == len(s):
            #result.append("".join(slate))
            return
        
        #recursive case
        else:
            #exclude case
            find_combinations_helper(s,i+1,slate,k)

            #include
            slate.append(s[i])
            find_combinations_helper(s,i+1,slate,k)
            slate.pop()

        return
    
    s = list(range(1,n+1))
    find_combinations_helper(s,0,slate,k)
    return result

print(find_combinations(5,2))